开发日志
--------------------------------------------------
[20181015]
- 创建了工作目录MangoMIPS32
- 创建了README.md和.gitignore
- 创建了DevLog.txt（该文件）作为工作开发日志
- 创建了defines.v，增加了完整指令译码的宏定义和部分其他宏定义
- 决定使用vscode代替Notepad++作为编辑器

--------------------------------------------------
[20181017]
- 修改了defines.v，增加了常数定义、线宽定义和ALUOp定义
  【注：ALUOp相关定义照搬MangoMIPS初代版本，可能有问题】

--------------------------------------------------
[20181023]
- 添加了PC.v、IF_ID.v，暂时是完善的
- 添加了ID.v，仅有大体的框架
- 添加了RegFile.v，优化了逻辑层次，已完善
- T: 适当照搬上个版本，能一定程度上减少工作量

--------------------------------------------------
[20181024]
- 把源代码移动到Src文件夹，整理了目录结构
- 微调defines.v

--------------------------------------------------
[20181025]
- T: 决定第一批实现的指令有：
-- SLL/SRL/SRA
-- SLLV/SRLV/SRAV
-- MOVZ/MOVN
-- ADD/ADDU/SUB/SUBU/AND/OR/XOR/NOR/SLT/SLTU
-- ADDI/ADDIU/SLTI/SLTIU/ANDI/ORI/XORI/LUI
- 已经实现这些指令的PC/IF/ID/EX段，后续未写
- 下一批实现：CLO/CLZ，HI/LO移动：CLO/CLZ已有思路，类似二分法，极大减少层数

--------------------------------------------------
[20181029]
- Q: alu运算结果可能作为写寄存器的数或者load的地址，前送时注意
- A: 增加memtoreg信号，load相关不在ex/mem进行任何前送
- 整理了模块结构，重命名部分模块
- 完成了能运行第一批指令的整体架构
- 移位、逻辑指令测试通过，算术、移动留待下一批测试
- 向master分支推送了以上所述的预览版本
- T: 第二批指令：
-- CLO/CLZ
-- MFHI/MTHI/MFLO/MTLO
-- SYNC/PREF [作为空指令执行]
-- MUL/MULT/MULTU
-- DIV/DIVU
-- MADD/MADDU/MSUB/MSUBU
- 为了方便综合出结果和后期调试，加上了NSCSCC2018指定的4个WB级信号作为输出
- 截至目前CLO/CLZ已经实现，未调试
- T: 由于MUL的输出是到寄存器的，暂定乘的阶段都在EX完成，乘累加再挪到MEM，即EX阶段只写HILO，MEM才有对HILO的读操作

--------------------------------------------------
[20181030]
- T: 把MUL操作的结果输出改回MEM段；乘累加、乘、HILO移动指令会与load指令相关处理方式相同，使用标记来判别
- T: 模块内部使用异步复位，在顶层将复位信号同步化，即，所有外来异步信号都应该被视为跨时钟域信号
- 初步添加了Control模块，还没适配
- 向Decode添加了MTHI/MTLO/MFHI/MFLO的解码
- T: TLB相关的CP0冲突暂不予处理，CP0放置在MEM段不变

--------------------------------------------------
[20181101]
- 适配了流水线控制模块，目前暂未连接有效的stallreq（全部接地）
- 添加了config.v，作为后期可配置选项的预留

--------------------------------------------------
[20181102]
- T: MFHI/MFLO在EX段就读取HILO的结果，不再进行流水线停顿，因为该种相关出现频率极高。
- T: 除此之外HILO寄存器的读取都发生在MEM段
- T: MUL相关发生频率较低，可以阻塞一拍。当前MEM段向寄存器输出结果的指令只剩各种load和MUL
- 由于保持HI和LO的写一致性能降低实现复杂度，将HI和LO的写使能信号重新合并
- HILO移动与乘法模块完成过半
- T: load相关实际上是要等到WB段才能传出结果的，类似的MUL相关如何处理？

--------------------------------------------------
[20181104]
- 用mem段alu合并的方式，使得MUL只用停1周期，访存照样停2周期
- 用ready信号表示指令是否产生结果, 用resnrdy表示
- 微调Decode.v达成上述结果
- 注意，顶层模块未修改
- 争议问题：关于横穿MultRes模块的alures信号命名问题：易读还是格式好？

--------------------------------------------------
[20181105]
- 格式在开发过程中多变，决定发布版本的时候再调整源代码格式
- 初步完成MultRes.v
- 加入了PREF的译码，SYNC/PREF作为NOP处理的译码完成
- 完成除法以外的第二批指令，进行测试
- T: 测试发现MFHI、MFLO读的回送路径超长，主要是MultRes对于hilo的长路径运算被回送
- 微调Decode.v格式，添加了遗漏的乘法指令译码
- T: SYNC和PREF都有比想象中更复杂的机制。它们的实现可以无限延后。
- 除法以外的第二批指令全部通过测试
- T: 要看最终完成后的Timing，所以目前100MHz下只要WNS为正都忽略
- MultRes.v更名MultDivRes.v
- 除法指令通过测试，第二批指令全部实现并通过测试
- 第三批指令：
-- J/JR/JAL/JALR
-- BEQ/BNE/BGTZ/BLEZ/BGEZ/BLTZ/BGEZAL/BLTZAL
-- 以上每一条对应的Branch Likely

--------------------------------------------------
[20181106]
- Q: 是否要为了缩短路径，将分支判断移回EX段？
- A: 都试试，往config.v里增加配置项，可以配置是否将分支判断放回ID
- 使用`ifdef的方式配置分支判断的位置

--------------------------------------------------
[20181107]
- T: 编写时序转换模块后就可以利用NSCSCC2018的sram_func进行功能测试
- 预先添加config项：是否启用TLB
- T: 大宽度的译码极大增加时延，可以对EX/MEM/WB段遇到的操作分别归类，减少译码的层次，主要是避免8宽度的译码每段都要进行一次
- T: 写内存的数据处理移到EX段，读内存的数据处理移到WB段，为MEM段减轻压力
- Q: 要不干脆把乘法的数据回送也移到WB？为分支指令在ID段执行创造条件
- T: 分支指令的执行频率远远大于乘法等指令，相关的发生概率也远大于它们，因此优化分支的气泡明显效果更优
- 将流水线寄存器模块全部添加前缀Reg_，将ALU更名为ALU_EX，MultDivRes更名为ALU_MEM

--------------------------------------------------
[20181108]
- T: 看了NSCSCC2018的答辩PPT，意识到性能和功能可能也无法兼得，TLB的存在影响性能
- T: 还是可以两手抓，把分支做在ID和EX的方案都准备一手
- T: TLB逻辑很多，考虑多拍返回
- T: 整体看路径，最后再修改，工作量不会很大
- T: EXCEL列指令，最后调整译码逻辑（实际上没什么可修改的了）
- 决定暂时只做ID段的跳转，选项性的东西后面再加
- 将PC+4的值往后送，减少后面运算量
- 完成J系列指令的译码
- 完成BEQ/BNE/BLEZ/BGTZ的译码，以及前面相应信号的适配（顶层未修改）
- 完成CACHE指令（按NOP处理）

--------------------------------------------------
[20181109]
- T: 译码逻辑的精简放到后期进行
- 流水线寄存器的if判断全部改case
- 定义了常量GRP_ra，指向31号寄存器
- 完成所有branch指令和branch likely指令的译码
- 完成B/BL指令，等待测试
- 发现严重的译码BUG：if/else结构判断sa字段是否为零会导致nop无法正确识别
- 解决：在每个指令处分别判断字段合法性（因为sa字段不具有唯一性）
- 通过仿真（配合openmips测试用例，入口地址改为0x0000_0000）

--------------------------------------------------
[20181112]
- defines.v改为Defines.v，并修改了所有其他文件中出现的地方
- T: DRAM没有字节选信号，解决方案就是用4个8位DRAM IP拼一个32位
- T: DRAM没有使能信号；
- T: 初步方案：EX段计算地址、分割写数据；MEM段只访存；WB段分割读数据
- 取消MemAccess.v，改为D-MMU，I/D-MMU先分开来做，最后重复度高了再整合
- alures和访存地址线分开
- T: CP0.Status.ERL=0时的地址映射是不一样的
- T: wreg信号启用字节写，能少送一个信号opr2，留作考虑
- 完成了load/store指令【除ll/sc】的各个模块，等待合并
- 加上了简陋的MMU_Inst，有待完善
- 顶层模块未修改
- T: 别忘了处理数据相关问题【在ALU_MEM处理，把load指令都停一拍】

--------------------------------------------------
[20181113]
- 访存部分暂时宣告完成，等待调试
- 对齐访存测试通过
- 由于非对齐访存如果读之前寄存器的内容会造成冲突，因此多位wreg势在必行

--------------------------------------------------
[20181114]
- wreg改造完成
- LWL/LWR/SWL/SWR通过测试
- 严重bug：opr1 & ~opr2 不能判断相等，已经改为异或
- 明天加访存stall信号，写接口，接入nscscc的sram func

--------------------------------------------------
[20181115]
- 为数据和指令接口添加了暂停请求信号
- sram_func测试通过至64点，前面的指令测试通过
- 将LLbit模块与hilo合并，减少模块数量
- LL/SC通过测试
- 下一批实现MFC0/MTC0以及相关CP0寄存器
- T: MEM段的Exception会需要处理llbit的读写问题
- 在Defines.v中添加了\CP0寄存器的相关定义
- CP0中试着添加了badvaddr/count/Compare
- T: 第一批添加的CP0寄存器：BadVAddr, Status, Cause, EPC

--------------------------------------------------
[20181116]
- T: 暂不实现Soft Reset和NMI异常
- Q: 如何在EX段实现User Mode访问核心内存空间的异常判断？
- A: 可以在MEM段判断，本来就是MMU的任务
- 初步添加Status和Cause寄存器

--------------------------------------------------
[20181117]
- Status.ERL暂缓实现
- 去掉了文件中所有的制表符，全部改为使用空格
- 初步完成CP0模块
- 去掉了所有的opr2的后送信号（已经注掉的也删了）
- T: MFC0也要在MEM段出结果

--------------------------------------------------
[20181118]
- 日程需要，短期停工
- 截至之前的进度，CP0已经嵌入顶层模块
- T: 用tab键对格式进行整理（实际上是空格）
- T: Status.UM可能是要实现的

--------------------------------------------------
[20181121]
- Config.v回来了，添加了去除延迟槽的设定
- CP0移动指令和Count/Compare通过测试
- T: 第一批准备实现的异常类型及优先级：
-- Int
-- I-AdEL
-- CpU
-- RI
-- Ov, Trap, Syscall, Bp,
-- D-AdEL/AdES
- T: COP1之类的关于CP1/CP2的指令不存在造成的异常暂时按照RI处理
- defines.v增加关于CP0寄存器的字段的定义
- defines.v增加关于异常相关的定义
- 直接实现ERL
- T: AdE中关于虚地址非法访问的判断不需要经过MMU
- 完成了Syscall/Break/Trap的译码段

--------------------------------------------------
[20181126]
- T: 好像是不会出现校验错误，不实现Cache Error异常
- 完善了defines.v中的异常种类
- 完成异常处理至MEM段，正在写Exception.v
- Control.v未完成，留待研究异常入口

--------------------------------------------------
[20181127]
- inslot 已经从前段往后传
- 添加了EX段对用户空间地址引起的AdE的判断
- T: Status.EXL=1时不更新EPC和Cause.BD
- 预留了所有要实现的异常类型的定义
- 修改sram_func_top.v，增加对异常的支持
- 为了提高效率，异常向量地址不使用加法计算，直接定义了运算的结果
- T: 使用flush和使用exc_flag的区别要注意
- T: 异常属于TLBL还是TLBS的判断另外加信号
- 初步完成异常，等待测试

--------------------------------------------------
[20181128]
- 通过NSCSCC-2018 sram_func_test
- sram_func不支持IV位，Config增加相关选项
- 完成对COP1/COP2判断为CpU的适配
- 修复了branch likely的一个重大BUG，并通过测试
- Trap通过测试
- 准备第一个发布版v1.0.0
- sram_func 95MHz impl通过，90MHz syn通过

--------------------------------------------------
[20181129]
- 完善了Fixed Mapping MMU,增加了ERL=0时的地址映射方式

--------------------------------------------------
[20181130]
- 更进一步完善了Fixed Mapping MMU，区分kseg2/3与kuseg
- 将两个MMU合并，实现为不同的实例
- 增加了ChangeLog.md，区别于DevLog
- CP0添加Config，未完成
- MMU增加了ifdef

--------------------------------------------------
[20181203]
- 实现了Config、Config1
- T: uncached存数操作加速？
- CP0初步添加了TLB所用的寄存器

--------------------------------------------------
[20181204]
- T: reftype信号直接从TLB给出，加上判断I/D
- 修改exception.v，增加了badvaddr在TLB异常下更新的情况
- 完成CP0添加的TLB寄存器
- 添加TLB.v用于放置TLB模块
- defines.v增加了CP0寄存器字段定义和TLB字段定义
- TLB模块开发中

--------------------------------------------------
[20181205]
- 脑公今天去踢tiu，所以这个日志是我的了！
- 可是并不知道该怎么捣乱啊，茫然猫头，要不唱首歌
- 我的名字叫三文鱼——
- T: ↑我回来一定把这只猫烤了吃
- T: 猫腿......吸溜......
- 增加.gitattributes

--------------------------------------------------
[20181206]
- T: 为性能牺牲，TLB项数固定位32项，放弃做通用
- T: 新算法解决bit计数问题，测试中
- 测试完成，直接使用casez暴力效率最高

--------------------------------------------------
[20181207]
- 优化CLO/CLZ算法，改成最优测试结果

--------------------------------------------------
[20181210]
- T: TLB、Cache存在暂停流水线同步访问的时序，需要好好思考
- 改进：ERET现在清零LLbit
- Q: 所有的流水线暂停都停到MEM段？毕竟停的周期数与停在哪一段是无关的
- A: 不行，ID段这么做会导致数据相关的解决陷入死循环
- IF段的暂停停到MEM段，ID段照常（照顾Cache/TLB指令的执行）
- T: Cache会引起TLB Exception, 但PREF不会。PREF遇到TLBE就不执行就是了
- 实现了WAIT指令，最终计划实现指令数量为100
- MMU重构，增加了cached属性

--------------------------------------------------
[20181211]
- IF段的暂停停到EX段，TLB操作信号不能在MEM段长留


--------------------------------------------------
[特别笔记区段]
需要的几场特别调试：
- User Mode CpU & AdEL
- COP1/COP2 CpU

指令集（计数用）：
SLL     SRL     SRA     SLLV    SRLV    SRAV    SYNC    PREF    CACHE   WAIT
AND     OR      XOR     NOR     MOVZ    MOVN    MFHI    MFLO    MTHI    MTLO
ANDI    ORI     XORI    LUI     ADD     ADDU    SUB     SUBU    SLT     SLTU
CLO     CLZ     ADDI    ADDIU   SLTI    SLTIU   MULT    MULTU   MADD    MADDU
MSUB    MSUBU   DIV     DIVU    MUL     SYSCALL BREAK   ERET    MFC0    MTC0
J       JAL     JR      JALR    BEQ     BNE     BGTZ    BLEZ    BGEZ    BGEZAL
BLTZ    BLTZAL  BEQL    BNEL    BGTZL   BLEZL   BGEZL   BGEZALL BLTZL   BLTZALL
LB      LBU     LH      LHU     LW      LWL     LWR     LL      SB      SH
SW      SWL     SWR     SC      TEQ     TNE     TGE     TGEU    TLT     TLTU
TEQI    TNEI    TGEI    TGEIU   TLTI    TLTIU   TLBR    TLBWI   TLBWR   TLBP

计划实现的CP0寄存器有：【后面备注批次】
- Index    (Register  0, Select 0)     //3
- Random   (Register  1, Select 0)     //3
- EntryLo0 (Register  2, Select 0)     //3
- EntryLo1 (Register  3, Select 0)     //3
- Context  (Register  4, Select 0)     //3
- PageMask (Register  5, Select 0)     //3
- Wired    (Register  6, Select 0)     //3
- BadVAddr (Register  8, Select 0)     
- Count    (Register  9, Select 0)     
- EntryHi  (Register 10, Select 0)     //3
- Compare  (Register 11, Select 0)     
- Status   (Register 12, Select 0)     
- Cause    (Register 13, Select 0)     
- EPC      (Register 14, Select 0)     
- PrId     (Register 15, Select 0)     
- EBase    (Register 15, Select 1)     //4 //可能不实现
- Config   (Register 16, Select 0)     //2
- Config1  (Register 16, Select 1)     //2
- TagLo    (Register 28, Select 0, 2)  //4
- TagHi    (Register 29, Select 0, 2)  //4

所有要实现的异常和优先级：
- Reset
- NMI  (暂缓)
- Int
- I-AdEL
- I-TLBR
- I-TLBI
- I_BusE
- CpU
- RI
- Ov, Trap, Syscall, Bp,
- D-AdEL/AdES
- D-TLBR
- D-TLBI
- D-TLBM
- D-BusE
- ERET

对MIPS32R1的全面适配，以下工作放到最后：
- 完整的SYNC/PREF
- ErrorEPC与NMI

总结经验
- 实际上把ALUOP某种程度上作为了指令的标志，不再只是ALU模块的控制信号；未来优化可以更多考虑空间换时间的问题
