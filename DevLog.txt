开发日志
--------------------------------------------------
[20181015]
- 创建了工作目录MangoMIPS32
- 创建了README.md和.gitignore
- 创建了DevLog.txt（该文件）作为工作开发日志
- 创建了defines.v，增加了完整指令译码的宏定义和部分其他宏定义
- 决定使用vscode代替Notepad++作为编辑器

--------------------------------------------------
[20181017]
- 修改了defines.v，增加了常数定义、线宽定义和ALUOp定义
  【注：ALUOp相关定义照搬MangoMIPS初代版本，可能有问题】

--------------------------------------------------
[20181023]
- 添加了PC.v、IF_ID.v，暂时是完善的
- 添加了ID.v，仅有大体的框架
- 添加了RegFile.v，优化了逻辑层次，已完善
- T: 适当照搬上个版本，能一定程度上减少工作量

--------------------------------------------------
[20181024]
- 把源代码移动到Src文件夹，整理了目录结构
- 微调defines.v

--------------------------------------------------
[20181025]
- T: 决定第一批实现的指令有：
-- SLL/SRL/SRA
-- SLLV/SRLV/SRAV
-- MOVZ/MOVN
-- ADD/ADDU/SUB/SUBU/AND/OR/XOR/NOR/SLT/SLTU
-- ADDI/ADDIU/SLTI/SLTIU/ANDI/ORI/XORI/LUI
- 已经实现这些指令的PC/IF/ID/EX段，后续未写
- 下一批实现：CLO/CLZ，HI/LO移动：CLO/CLZ已有思路，类似二分法，极大减少层数

--------------------------------------------------
[20181029]
- Q: alu运算结果可能作为写寄存器的数或者load的地址，前送时注意
- A: 增加memtoreg信号，load相关不在ex/mem进行任何前送
- 整理了模块结构，重命名部分模块
- 完成了能运行第一批指令的整体架构
- 移位、逻辑指令测试通过，算术、移动留待下一批测试
- 向master分支推送了以上所述的预览版本
- T: 第二批指令：
-- CLO/CLZ
-- MFHI/MTHI/MFLO/MTLO
-- SYNC/PREF [作为空指令执行]
-- MUL/MULT/MULTU
-- DIV/DIVU
-- MADD/MADDU/MSUB/MSUBU
- 为了方便综合出结果和后期调试，加上了NSCSCC2018指定的4个WB级信号作为输出
- 截至目前CLO/CLZ已经实现，未调试
- T: 由于MUL的输出是到寄存器的，暂定乘的阶段都在EX完成，乘累加再挪到MEM，即EX阶段只写HILO，MEM才有对HILO的读操作

--------------------------------------------------
[20181030]
- T: 把MUL操作的结果输出改回MEM段；乘累加、乘、HILO移动指令会与load指令相关处理方式相同，使用标记来判别
- T: 模块内部使用异步复位，在顶层将复位信号同步化，即，所有外来异步信号都应该被视为跨时钟域信号
- 初步添加了Control模块，还没适配
- 向Decode添加了MTHI/MTLO/MFHI/MFLO的解码
- T: TLB相关的CP0冲突暂不予处理，CP0放置在MEM段不变

--------------------------------------------------
[20181101]
- 适配了流水线控制模块，目前暂未连接有效的stallreq（全部接地）
- 添加了config.v，作为后期可配置选项的预留

--------------------------------------------------
[20181102]
- T: MFHI/MFLO在EX段就读取HILO的结果，不再进行流水线停顿，因为该种相关出现频率极高。
- T: 除此之外HILO寄存器的读取都发生在MEM段
- T: MUL相关发生频率较低，可以阻塞一拍。当前MEM段向寄存器输出结果的指令只剩各种load和MUL
- 由于保持HI和LO的写一致性能降低实现复杂度，将HI和LO的写使能信号重新合并
- HILO移动与乘法模块完成过半
- T: load相关实际上是要等到WB段才能传出结果的，类似的MUL相关如何处理？

--------------------------------------------------
[20181104]
- 用mem段alu合并的方式，使得MUL只用停1周期，访存照样停2周期
- 用ready信号表示指令是否产生结果, 用resnrdy表示
- 微调Decode.v达成上述结果
- 注意，顶层模块未修改
- 争议问题：关于横穿MultRes模块的alures信号命名问题：易读还是格式好？

--------------------------------------------------
[20181105]
- 格式在开发过程中多变，决定发布版本的时候再调整源代码格式
- 初步完成MultRes.v
- 加入了PREF的译码，SYNC/PREF作为NOP处理的译码完成
- 完成除法以外的第二批指令，进行测试
- T: 测试发现MFHI、MFLO读的回送路径超长，主要是MultRes对于hilo的长路径运算被回送
- 微调Decode.v格式，添加了遗漏的乘法指令译码
- T: SYNC和PREF都有比想象中更复杂的机制。它们的实现可以无限延后。
- 除法以外的第二批指令全部通过测试
- T: 要看最终完成后的Timing，所以目前100MHz下只要WNS为正都忽略
- MultRes.v更名MultDivRes.v
- 除法指令通过测试，第二批指令全部实现并通过测试
- 第三批指令：
-- J/JR/JAL/JALR
-- BEQ/BNE/BGTZ/BLEZ/BGEZ/BLTZ/BGEZAL/BLTZAL
-- 以上每一条对应的Branch Likely

--------------------------------------------------
[20181106]
- Q: 是否要为了缩短路径，将分支判断移回EX段？
- A: 都试试，往config.v里增加配置项，可以配置是否将分支判断放回ID
- 使用`ifdef的方式配置分支判断的位置

--------------------------------------------------
[20181107]
- T: 编写时序转换模块后就可以利用NSCSCC2018的sram_func进行功能测试
- 预先添加config项：是否启用TLB
- T: 大宽度的译码极大增加时延，可以对EX/MEM/WB段遇到的操作分别归类，减少译码的层次，主要是避免8宽度的译码每段都要进行一次
- T: 写内存的数据处理移到EX段，读内存的数据处理移到WB段，为MEM段减轻压力
- Q: 要不干脆把乘法的数据回送也移到WB？为分支指令在ID段执行创造条件
- T: 分支指令的执行频率远远大于乘法等指令，相关的发生概率也远大于它们，因此优化分支的气泡明显效果更优
- 将流水线寄存器模块全部添加前缀Reg_，将ALU更名为ALU_EX，MultDivRes更名为ALU_MEM

--------------------------------------------------
[20181108]
- T: 看了NSCSCC2018的答辩PPT，意识到性能和功能可能也无法兼得，TLB的存在影响性能
- T: 还是可以两手抓，把分支做在ID和EX的方案都准备一手
- T: TLB逻辑很多，考虑多拍返回
- T: 整体看路径，最后再修改，工作量不会很大
- T: EXCEL列指令，最后调整译码逻辑（实际上没什么可修改的了）
- 决定暂时只做ID段的跳转，选项性的东西后面再加
- 将PC+4的值往后送，减少后面运算量
- 完成J系列指令的译码
- 完成BEQ/BNE/BLEZ/BGTZ的译码，以及前面相应信号的适配（顶层未修改）
- 完成CACHE指令（按NOP处理）

--------------------------------------------------
[20181109]
- T: 译码逻辑的精简放到后期进行
- 流水线寄存器的if判断全部改case
- 定义了常量GRP_ra，指向31号寄存器
- 完成所有branch指令和branch likely指令的译码
- 完成B/BL指令，等待测试
- 发现严重的译码BUG：if/else结构判断sa字段是否为零会导致nop无法正确识别
- 解决：在每个指令处分别判断字段合法性（因为sa字段不具有唯一性）
- 通过仿真（配合openmips测试用例，入口地址改为0x0000_0000）

--------------------------------------------------
[20181112]
- defines.v改为Defines.v，并修改了所有其他文件中出现的地方
- T: DRAM没有字节选信号，解决方案就是用4个8位DRAM IP拼一个32位
- T: DRAM没有使能信号；
- T: 初步方案：EX段计算地址、分割写数据；MEM段只访存；WB段分割读数据
- 取消MemAccess.v，改为D-MMU，I/D-MMU先分开来做，最后重复度高了再整合
- alures和访存地址线分开
- T: CP0.Status.ERL=0时的地址映射是不一样的
- T: wreg信号启用字节写，能少送一个信号opr2，留作考虑
- 完成了load/store指令【除ll/sc】的各个模块，等待合并
- 加上了简陋的MMU_Inst，有待完善
- 顶层模块未修改
- T: 别忘了处理数据相关问题【在ALU_MEM处理，把load指令都停一拍】

--------------------------------------------------
[20181113]
- 访存部分暂时宣告完成，等待调试
- 对齐访存测试通过
- 由于非对齐访存如果读之前寄存器的内容会造成冲突，因此多位wreg势在必行

--------------------------------------------------
[20181114]
- wreg改造完成
- LWL/LWR/SWL/SWR通过测试
- 严重bug：opr1 & ~opr2 不能判断相等，已经改为异或
- 明天加访存stall信号，写接口，接入nscscc的sram func

--------------------------------------------------
[20181115]
- 为数据和指令接口添加了暂停请求信号
- sram_func测试通过至64点，前面的指令测试通过
- 将LLbit模块与hilo合并，减少模块数量
- LL/SC通过测试
- 下一批实现MFC0/MTC0以及相关CP0寄存器
- T: MEM段的Exception会需要处理llbit的读写问题
- 在Defines.v中添加了\CP0寄存器的相关定义
- CP0中试着添加了badvaddr/count/Compare
- T: 第一批添加的CP0寄存器：BadVAddr, Status, Cause, EPC

--------------------------------------------------
[20181116]
- T: 暂不实现Soft Reset和NMI异常
- Q: 如何在EX段实现User Mode访问核心内存空间的异常判断？
- A: 可以在MEM段判断，本来就是MMU的任务
- 初步添加Status和Cause寄存器

--------------------------------------------------
[20181117]
- Status.ERL暂缓实现
- 去掉了文件中所有的制表符，全部改为使用空格
- 初步完成CP0模块
- 去掉了所有的opr2的后送信号（已经注掉的也删了）
- T: MFC0也要在MEM段出结果

--------------------------------------------------
[20181118]
- 日程需要，短期停工
- 截至之前的进度，CP0已经嵌入顶层模块
- T: 用tab键对格式进行整理（实际上是空格）
- T: Status.UM可能是要实现的

--------------------------------------------------
[20181121]
- Config.v回来了，添加了去除延迟槽的设定
- CP0移动指令和Count/Compare通过测试
- T: 第一批准备实现的异常类型及优先级：
-- Int
-- I-AdEL
-- CpU
-- RI
-- Ov, Trap, Syscall, Bp,
-- D-AdEL/AdES
- T: COP1之类的关于CP1/CP2的指令不存在造成的异常暂时按照RI处理
- defines.v增加关于CP0寄存器的字段的定义
- defines.v增加关于异常相关的定义
- 直接实现ERL
- T: AdE中关于虚地址非法访问的判断不需要经过MMU
- 完成了Syscall/Break/Trap的译码段

--------------------------------------------------
[20181126]
- T: 好像是不会出现校验错误，不实现Cache Error异常
- 完善了defines.v中的异常种类
- 完成异常处理至MEM段，正在写Exception.v
- Control.v未完成，留待研究异常入口

--------------------------------------------------
[20181127]
- inslot 已经从前段往后传
- 添加了EX段对用户空间地址引起的AdE的判断
- T: Status.EXL=1时不更新EPC和Cause.BD
- 预留了所有要实现的异常类型的定义
- 修改sram_func_top.v，增加对异常的支持
- 为了提高效率，异常向量地址不使用加法计算，直接定义了运算的结果
- T: 使用flush和使用exc_flag的区别要注意
- T: 异常属于TLBL还是TLBS的判断另外加信号
- 初步完成异常，等待测试

--------------------------------------------------
[20181128]
- 通过NSCSCC-2018 sram_func_test
- sram_func不支持IV位，Config增加相关选项
- 完成对COP1/COP2判断为CpU的适配
- 修复了branch likely的一个重大BUG，并通过测试
- Trap通过测试
- 准备第一个发布版v1.0.0
- sram_func 95MHz impl通过，90MHz syn通过

--------------------------------------------------
[20181129]
- 完善了Fixed Mapping MMU,增加了ERL=0时的地址映射方式

--------------------------------------------------
[20181130]
- 更进一步完善了Fixed Mapping MMU，区分kseg2/3与kuseg
- 将两个MMU合并，实现为不同的实例
- 增加了ChangeLog.md，区别于DevLog
- CP0添加Config，未完成
- MMU增加了ifdef

--------------------------------------------------
[20181203]
- 实现了Config、Config1
- T: uncached存数操作加速？
- CP0初步添加了TLB所用的寄存器

--------------------------------------------------
[20181204]
- T: reftype信号直接从TLB给出，加上判断I/D
- 修改exception.v，增加了badvaddr在TLB异常下更新的情况
- 完成CP0添加的TLB寄存器
- 添加TLB.v用于放置TLB模块
- defines.v增加了CP0寄存器字段定义和TLB字段定义
- TLB模块开发中

--------------------------------------------------
[20181205]
- 脑公今天去踢tiu，所以这个日志是我的了！
- 可是并不知道该怎么捣乱啊，茫然猫头，要不唱首歌
- 我的名字叫三文鱼——
- T: ↑我回来一定把这只猫烤了吃
- T: 猫腿......吸溜......
- 增加.gitattributes

--------------------------------------------------
[20181206]
- T: 为性能牺牲，TLB项数固定位32项，放弃做通用
- T: 新算法解决bit计数问题，测试中
- 测试完成，直接使用casez暴力效率最高

--------------------------------------------------
[20181207]
- 优化CLO/CLZ算法，改成最优测试结果

--------------------------------------------------
[20181210]
- T: TLB、Cache存在暂停流水线同步访问的时序，需要好好思考
- 改进：ERET现在清零LLbit
- Q: 所有的流水线暂停都停到MEM段？毕竟停的周期数与停在哪一段是无关的
- A: 不行，ID段这么做会导致数据相关的解决陷入死循环
- IF段的暂停停到MEM段，ID段照常（照顾Cache/TLB指令的执行）
- T: Cache会引起TLB Exception, 但PREF不会。PREF遇到TLBE就不执行就是了
- 实现了WAIT指令，最终计划实现指令数量为100
- MMU重构，增加了cached属性

--------------------------------------------------
[20181211]
- IF段的暂停停到EX段，TLB操作信号不能在MEM段长留

--------------------------------------------------
[20181212]
- TLB单模块仿真通过
- TLB适配：顶层模块修改完毕

--------------------------------------------------
[20181214]
- 通过axi_func
- 将MUL结果返回移到WB段，降低了路径长度
- 性能分1.750@100MHz
- 调换了Config和Defines的include顺序，解决互相依赖问题

--------------------------------------------------
[20181216]
- 修复了误以为Config.K0/KU/K23是1位的问题；Cache_Attribute应该是3位的属性
- NSCSCC模式下FM-MMU复位K0/KU/K23可缓存，TLB-MMU复位K0可缓存。

--------------------------------------------------
[20181217]
- T: TagHi和TagLo按照龙芯手册实现即可
- 添加了CACHE指令编码定义
- 细微优化ALU_MEM
- Decode的Cache指令位置预留了编码
- T: PREF指令无限延后，SYNC指令就作为空指令
- Config添加了Cache配置项
- T: Cache的宏定义项不放进defines，因为全局一般用不着
- Inst_Cache 开发中
- T: inst cache的cache指令问题
- Q: dist_mem貌似只有一个写端口，在DCache里怎么用要思考

--------------------------------------------------
[20181218]
- ICache使用伪双口RAM；DCache用单口RAM+多路选择
- Q: Uncache访存和除法计算都不能正确地等待stall信号降低，没出问题是因为恰好在一个时刻他们都释放了streq
- 初步完成ICache，优化中
- T: 在stall中不重复操作，要么判断操作数与锁定的相同，要么判断stall信号是否自身发起
- 修复了CLO/CLZ在使用新算法后不能正确运行的bug【可能由版本控制不佳引起】
- 修复CP0的tlb index信号的位宽问题，现在传过来的index是32位宽，包含了P位
- Config.v整理中，不能直接用，还没改对应点

--------------------------------------------------
[20181219]
- Config.v整理完毕
- T: div开始请求和暂停请求的合并，抹杀了div模块防止重复计算的努力
- T: 以上问题尚未解决

--------------------------------------------------
[20181220]
- 解决了div stall和取指stall发生互锁的问题
- Q: 在添加Cache之后，TLB出来时钟路径过长
- T: TLB在进来之后先译码，输出时同步输出，减少延迟
- 修复TLB的cacheability造成的长链问题
- TLB的rdy的滥用导致长链
- T: clrslot是否可以抑制取指？会否继续造成长链？
- T: PC需要TLB翻译的指令不存在被另一条这样的指令打断的情况（异常发生后一定跳转到unmapped地址）
- T: 数据访存地址需要TLB翻译的指令不存在被另一条这样的指令打断的情况（异常发生后清零）
- 由于以上两个原因，MMU的tlb异常信号不需要再与rdy相与

#重要：关于流水线中的同步模块的访问时序问题
- 访存：地址中途会变化、可能中途撤销请求、连续同地址访问不缓存
- 除法器：中途撤销的请求由flush信号控制；操作数中途不变，几乎没有连续访问可能
- TLB： 会中途撤销请求，地址中途不变，会连续访问，不缓存

--------------------------------------------------
[20181221]
- T: 当前数据回送不能保证回送的数据每一字节均为最新；
- 修改RegFile.v的回送策略
- 简化了ICache的valid判断和streq判断
- 其他测试都过了，Coremark发生异常
- 异常原因：由于缓存读错误，执行了一条不该执行的指令
- BUG: 在检测到rlast的时候其实cache_ram并没有写入最后一个数据
- T: 用停留在那个状态，来维持valid信号，而不是靠不清零

--------------------------------------------------
[20181222]
- 修复昨天的BUG
- ICache通过测试，性能分：8.703@90MHz， 9.647@100MHz
- Q: 宏定义重复的问题需要解决

--------------------------------------------------
[20181224]
- T: 综合时序和布局布线时序相差过大的缘故推测为扇出过高的因素
- 修复Fixed-Mapping MMU 下的路径过长问题
- T: 宏定义重复问题未解决
- T: 扇出过高是由于reset信号接了各种LUTRAM的复位
- A: 把复位改成initial即可，不复位

--------------------------------------------------
[20181225]
- 圣诞快乐
- 修复了扇出过高的问题
- T: L2Cache可以做，放到最后
- 解决了宏定义重复问题
- Data Cache 通过功能测试

--------------------------------------------------
[20181226]
- WNS过高，原因未知
- 通过性能测试：I4K, D4K, 35.633@90MHz. 其中Stream_copy测试只有3.90
- 原因：缓存容量过小，写分配导致大量的写回与读操作
- T: 性能问题不再是当务之急，要完成开发Cache指令的逻辑
- 性能测试：I8K, D8K, 50.056@90MHz

--------------------------------------------------
[20181228]
- defines增加了CacheOp定义和ALU_CACHE
- 根据指令类型微调了ALUOp编码，提高译码效率
- 译码段增加Cache指令译码
- 执行阶段增加Cache指令的地址计算和AdEL异常（用户态下），与LB/LBU共用一个case项
- T: Cache的Index和Hit操作的区别在于，前者取出地址中的某一段作为index，操作必定成功；后者只有tag完全命中才操作成功
- T: 由于是直接映射Cache，Index操作中的Way不必设置
- T: 与TLB联动时，dbus_en可作为paddr准备好的标志
- T: 进一步的，单独送en、cache地址、cache命令给ICache；DCache则可以直接使用dbus_en和dbus_addr
- 修复CP0 Index/Wired/Random寄存器数值异常的问题 

--------------------------------------------------
[20181229]
- 无Cache测试通过PMON。
- T: axi的地址必须32位对齐【针对soc_up】
- [已回滚]MMU出来的物理地址就将末两位裁掉
- AXI_Interface 修复了等待时反复访存bug
- MangoMIPS32对外接口改为单个AXI接口。
- T: lb/sb和lh/sh的操作需要体现在AXI总线上，不能直接全32位操作

--------------------------------------------------
[特别笔记区段]
需要的几场特别调试：
- CacheOp
- User Mode CpU & AdEL
- COP1/COP2 CpU

指令集（计数用）：
SLL     SRL     SRA     SLLV    SRLV    SRAV    SYNC    PREF    CACHE   WAIT
AND     OR      XOR     NOR     MOVZ    MOVN    MFHI    MFLO    MTHI    MTLO
ANDI    ORI     XORI    LUI     ADD     ADDU    SUB     SUBU    SLT     SLTU
CLO     CLZ     ADDI    ADDIU   SLTI    SLTIU   MULT    MULTU   MADD    MADDU
MSUB    MSUBU   DIV     DIVU    MUL     SYSCALL BREAK   ERET    MFC0    MTC0
J       JAL     JR      JALR    BEQ     BNE     BGTZ    BLEZ    BGEZ    BGEZAL
BLTZ    BLTZAL  BEQL    BNEL    BGTZL   BLEZL   BGEZL   BGEZALL BLTZL   BLTZALL
LB      LBU     LH      LHU     LW      LWL     LWR     LL      SB      SH
SW      SWL     SWR     SC      TEQ     TNE     TGE     TGEU    TLT     TLTU
TEQI    TNEI    TGEI    TGEIU   TLTI    TLTIU   TLBR    TLBWI   TLBWR   TLBP

CACHE操作类型：
- I-Index Invalidate
- D-Index Writeback Invalidate
- I/D-Index Store Tag
- I/D-Hit Invalidate
- D-Hit Writeback Invalidate

计划实现的CP0寄存器有：【后面备注批次】
- Index    (Register  0, Select 0)     
- Random   (Register  1, Select 0)     
- EntryLo0 (Register  2, Select 0)     
- EntryLo1 (Register  3, Select 0)     
- Context  (Register  4, Select 0)     
- PageMask (Register  5, Select 0)     
- Wired    (Register  6, Select 0)     
- BadVAddr (Register  8, Select 0)     
- Count    (Register  9, Select 0)     
- EntryHi  (Register 10, Select 0)     
- Compare  (Register 11, Select 0)     
- Status   (Register 12, Select 0)     
- Cause    (Register 13, Select 0)     
- EPC      (Register 14, Select 0)     
- PrId     (Register 15, Select 0)     
- EBase    (Register 15, Select 1)     //4 //可能不实现
- Config   (Register 16, Select 0)     
- Config1  (Register 16, Select 1)     
- TagLo    (Register 28, Select 0, 2)  //4
- TagHi    (Register 29, Select 0, 2)  //4

所有要实现的异常和优先级：
- Reset
- NMI  (暂缓)
- Int
- I-AdEL
- I-TLBR
- I-TLBI
- I_BusE
- CpU
- RI
- Ov, Trap, Syscall, Bp,
- D-AdEL/AdES
- D-TLBR
- D-TLBI
- D-TLBM
- D-BusE
- ERET

对MIPS32R1的全面适配，以下工作放到最后：
- 完整的PREF
- ErrorEPC与NMI
- L2Cache

总结经验
- 实际上把ALUOP某种程度上作为了指令的标志，不再只是ALU模块的控制信号；未来优化可以更多考虑空间换时间的问题
